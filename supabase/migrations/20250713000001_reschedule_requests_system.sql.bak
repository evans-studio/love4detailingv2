-- Migration: Reschedule Requests System
-- Create tables and procedures for customer reschedule requests with admin approval workflow

-- Create reschedule_requests table
CREATE TABLE IF NOT EXISTS reschedule_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    current_slot_id UUID NOT NULL REFERENCES available_slots(id),
    requested_slot_id UUID NOT NULL REFERENCES available_slots(id),
    reason TEXT,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'declined', 'cancelled')),
    admin_response TEXT,
    admin_id UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    responded_at TIMESTAMPTZ,
    
    -- Constraints
    CONSTRAINT reschedule_different_slots CHECK (current_slot_id != requested_slot_id),
    CONSTRAINT reschedule_one_pending_per_booking UNIQUE (booking_id) WHERE status = 'pending'
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_booking_id ON reschedule_requests(booking_id);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_user_id ON reschedule_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_status ON reschedule_requests(status);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_created_at ON reschedule_requests(created_at);

-- Enable RLS
ALTER TABLE reschedule_requests ENABLE ROW LEVEL SECURITY;

-- RLS Policies for reschedule_requests
CREATE POLICY "Users can view their own reschedule requests"
    ON reschedule_requests FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create reschedule requests for their own bookings"
    ON reschedule_requests FOR INSERT
    WITH CHECK (
        auth.uid() = user_id AND
        EXISTS (
            SELECT 1 FROM bookings 
            WHERE id = booking_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update their own pending reschedule requests"
    ON reschedule_requests FOR UPDATE
    USING (auth.uid() = user_id AND status = 'pending')
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Admins can view all reschedule requests"
    ON reschedule_requests FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = auth.uid() AND role IN ('admin', 'staff')
        )
    );

CREATE POLICY "Admins can update reschedule request status"
    ON reschedule_requests FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = auth.uid() AND role IN ('admin', 'staff')
        )
    );

-- Function to create reschedule request
CREATE OR REPLACE FUNCTION create_reschedule_request(
    p_booking_id UUID,
    p_requested_slot_id UUID,
    p_reason TEXT DEFAULT NULL
) RETURNS TABLE (
    success BOOLEAN,
    request_id UUID,
    message TEXT
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_user_id UUID;
    v_current_slot_id UUID;
    v_booking_status TEXT;
    v_request_id UUID;
    v_slot_available BOOLEAN;
BEGIN
    -- Get current user
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, 'User not authenticated';
        RETURN;
    END IF;

    -- Get current booking details
    SELECT slot_id, status INTO v_current_slot_id, v_booking_status
    FROM bookings 
    WHERE id = p_booking_id AND user_id = v_user_id;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, 'Booking not found or access denied';
        RETURN;
    END IF;

    -- Check if booking can be rescheduled
    IF v_booking_status NOT IN ('confirmed', 'pending') THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, 'Booking cannot be rescheduled in current status';
        RETURN;
    END IF;

    -- Check if requested slot is available
    SELECT is_available INTO v_slot_available
    FROM available_slots
    WHERE id = p_requested_slot_id;

    IF NOT FOUND OR NOT v_slot_available THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, 'Requested time slot is not available';
        RETURN;
    END IF;

    -- Check for existing pending request
    IF EXISTS (
        SELECT 1 FROM reschedule_requests 
        WHERE booking_id = p_booking_id AND status = 'pending'
    ) THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, 'A reschedule request is already pending for this booking';
        RETURN;
    END IF;

    -- Create reschedule request
    INSERT INTO reschedule_requests (
        booking_id, 
        user_id, 
        current_slot_id, 
        requested_slot_id, 
        reason
    ) VALUES (
        p_booking_id,
        v_user_id,
        v_current_slot_id,
        p_requested_slot_id,
        p_reason
    ) RETURNING id INTO v_request_id;

    RETURN QUERY SELECT TRUE, v_request_id, 'Reschedule request created successfully';
END;
$$;

-- Function to respond to reschedule request (admin only)
CREATE OR REPLACE FUNCTION respond_to_reschedule_request(
    p_request_id UUID,
    p_decision TEXT, -- 'approved' or 'declined'
    p_admin_response TEXT DEFAULT NULL
) RETURNS TABLE (
    success BOOLEAN,
    message TEXT
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_admin_id UUID;
    v_request_record reschedule_requests%ROWTYPE;
    v_is_admin BOOLEAN;
BEGIN
    -- Get current user and verify admin
    v_admin_id := auth.uid();
    IF v_admin_id IS NULL THEN
        RETURN QUERY SELECT FALSE, 'User not authenticated';
        RETURN;
    END IF;

    -- Check if user is admin
    SELECT EXISTS(
        SELECT 1 FROM users 
        WHERE id = v_admin_id AND role IN ('admin', 'staff')
    ) INTO v_is_admin;

    IF NOT v_is_admin THEN
        RETURN QUERY SELECT FALSE, 'Admin access required';
        RETURN;
    END IF;

    -- Validate decision
    IF p_decision NOT IN ('approved', 'declined') THEN
        RETURN QUERY SELECT FALSE, 'Invalid decision. Must be approved or declined';
        RETURN;
    END IF;

    -- Get reschedule request
    SELECT * INTO v_request_record
    FROM reschedule_requests
    WHERE id = p_request_id AND status = 'pending';

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Reschedule request not found or already processed';
        RETURN;
    END IF;

    -- If approved, check if requested slot is still available
    IF p_decision = 'approved' THEN
        IF NOT EXISTS (
            SELECT 1 FROM available_slots 
            WHERE id = v_request_record.requested_slot_id AND is_available = TRUE
        ) THEN
            RETURN QUERY SELECT FALSE, 'Requested time slot is no longer available';
            RETURN;
        END IF;

        -- Update booking with new slot
        UPDATE bookings 
        SET slot_id = v_request_record.requested_slot_id,
            updated_at = NOW()
        WHERE id = v_request_record.booking_id;

        -- Mark new slot as unavailable
        UPDATE available_slots 
        SET is_available = FALSE 
        WHERE id = v_request_record.requested_slot_id;

        -- Mark old slot as available
        UPDATE available_slots 
        SET is_available = TRUE 
        WHERE id = v_request_record.current_slot_id;
    END IF;

    -- Update reschedule request
    UPDATE reschedule_requests
    SET status = p_decision,
        admin_response = p_admin_response,
        admin_id = v_admin_id,
        responded_at = NOW(),
        updated_at = NOW()
    WHERE id = p_request_id;

    RETURN QUERY SELECT TRUE, 'Reschedule request ' || p_decision || ' successfully';
END;
$$;

-- Function to get reschedule requests for admin
CREATE OR REPLACE FUNCTION get_admin_reschedule_requests(
    p_status TEXT DEFAULT NULL,
    p_limit INTEGER DEFAULT 50
) RETURNS TABLE (
    request_id UUID,
    booking_id UUID,
    booking_reference TEXT,
    customer_name TEXT,
    customer_email TEXT,
    service_name TEXT,
    current_date DATE,
    current_time TIME,
    requested_date DATE,
    requested_time TIME,
    reason TEXT,
    status TEXT,
    created_at TIMESTAMPTZ,
    admin_response TEXT
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
BEGIN
    -- Get current user and verify admin
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'User not authenticated';
    END IF;

    -- Check if user is admin
    SELECT EXISTS(
        SELECT 1 FROM users 
        WHERE id = v_user_id AND role IN ('admin', 'staff')
    ) INTO v_is_admin;

    IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;

    -- Return reschedule requests with booking details
    RETURN QUERY
    SELECT 
        rr.id,
        rr.booking_id,
        b.booking_reference,
        COALESCE(u.full_name, b.customer_name, 'Unknown') as customer_name,
        COALESCE(u.email, b.customer_email, '') as customer_email,
        COALESCE(s.name, 'Unknown Service') as service_name,
        cs.slot_date as current_date,
        cs.start_time::TIME as current_time,
        rs.slot_date as requested_date,
        rs.start_time::TIME as requested_time,
        rr.reason,
        rr.status,
        rr.created_at,
        rr.admin_response
    FROM reschedule_requests rr
    JOIN bookings b ON rr.booking_id = b.id
    LEFT JOIN users u ON rr.user_id = u.id
    LEFT JOIN services s ON b.service_id = s.id
    JOIN available_slots cs ON rr.current_slot_id = cs.id
    JOIN available_slots rs ON rr.requested_slot_id = rs.id
    WHERE (p_status IS NULL OR rr.status = p_status)
    ORDER BY 
        CASE WHEN rr.status = 'pending' THEN 0 ELSE 1 END,
        rr.created_at DESC
    LIMIT p_limit;
END;
$$;

-- Create notification trigger for new reschedule requests
CREATE OR REPLACE FUNCTION notify_reschedule_request() 
RETURNS TRIGGER AS $$
BEGIN
    -- Insert notification for admins
    INSERT INTO notifications (
        user_id,
        type,
        title,
        message,
        data,
        created_at
    )
    SELECT 
        u.id,
        'reschedule_request',
        'New Reschedule Request',
        'Customer has requested to reschedule booking ' || 
        (SELECT booking_reference FROM bookings WHERE id = NEW.booking_id),
        jsonb_build_object(
            'request_id', NEW.id,
            'booking_id', NEW.booking_id,
            'user_id', NEW.user_id
        ),
        NOW()
    FROM users u
    WHERE u.role IN ('admin', 'staff');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for reschedule request notifications
DROP TRIGGER IF EXISTS trigger_reschedule_request_notification ON reschedule_requests;
CREATE TRIGGER trigger_reschedule_request_notification
    AFTER INSERT ON reschedule_requests
    FOR EACH ROW
    EXECUTE FUNCTION notify_reschedule_request();

-- Grant necessary permissions
GRANT SELECT, INSERT, UPDATE ON reschedule_requests TO authenticated;
GRANT EXECUTE ON FUNCTION create_reschedule_request TO authenticated;
GRANT EXECUTE ON FUNCTION respond_to_reschedule_request TO authenticated;
GRANT EXECUTE ON FUNCTION get_admin_reschedule_requests TO authenticated;