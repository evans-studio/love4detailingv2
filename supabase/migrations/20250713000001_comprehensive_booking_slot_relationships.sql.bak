-- =========================================================================
-- Love4Detailing - Comprehensive Booking & Slot Relationship Management
-- Migration: Enhanced data integrity and visual feedback system
-- =========================================================================

-- First, backup existing data structure by creating a backup of current tables
-- Create backup of existing available_slots
CREATE TABLE available_slots_backup AS SELECT * FROM available_slots;

-- Create backup of existing bookings  
CREATE TABLE bookings_backup AS SELECT * FROM bookings;

-- =========================================================================
-- Phase 1: Enhanced Available Slots Table
-- =========================================================================

-- Add new columns to available_slots table for complete slot management
ALTER TABLE available_slots 
ADD COLUMN IF NOT EXISTS booking_id UUID REFERENCES bookings(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS reserved_for_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS reserved_until TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS slot_status TEXT DEFAULT 'available' CHECK (slot_status IN (
  'available', 
  'temporarily_reserved', 
  'booked', 
  'pending_reschedule', 
  'reschedule_reserved', 
  'cancelled'
)),
ADD COLUMN IF NOT EXISTS created_by_admin UUID REFERENCES auth.users(id),
ADD COLUMN IF NOT EXISTS last_modified TIMESTAMPTZ DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS modification_reason TEXT;

-- Add missing columns if they don't exist
ALTER TABLE available_slots 
ADD COLUMN IF NOT EXISTS end_time TIME,
ADD COLUMN IF NOT EXISTS max_bookings INTEGER DEFAULT 1;

-- Ensure current_bookings exists and has proper default
ALTER TABLE available_slots 
ALTER COLUMN current_bookings SET DEFAULT 0;

-- Update end_time based on start_time + 2 hours (standard service duration)
UPDATE available_slots 
SET end_time = (start_time::time + interval '2 hours')::time 
WHERE end_time IS NULL;

-- =========================================================================
-- Phase 1: Enhanced Bookings Table  
-- =========================================================================

-- Add relationship and tracking columns to bookings table
ALTER TABLE bookings
ADD COLUMN IF NOT EXISTS original_slot_id UUID REFERENCES available_slots(id),
ADD COLUMN IF NOT EXISTS current_slot_id UUID REFERENCES available_slots(id),
ADD COLUMN IF NOT EXISTS booking_history JSONB DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS reschedule_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_status_change TIMESTAMPTZ DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS status_change_reason TEXT,
ADD COLUMN IF NOT EXISTS created_from_reschedule BOOLEAN DEFAULT FALSE;

-- Add slot_id column if it doesn't exist (for backward compatibility)
ALTER TABLE bookings 
ADD COLUMN IF NOT EXISTS slot_id UUID REFERENCES available_slots(id);

-- Update current_slot_id to match slot_id for existing bookings
UPDATE bookings 
SET current_slot_id = slot_id, original_slot_id = slot_id 
WHERE current_slot_id IS NULL AND slot_id IS NOT NULL;

-- Enhance status column to support new booking lifecycle states
-- First check if we need to modify the status column constraint
DO $$ 
BEGIN
  -- Drop existing constraint if it exists
  ALTER TABLE bookings DROP CONSTRAINT IF EXISTS bookings_status_check;
  
  -- Add new constraint with enhanced status options
  ALTER TABLE bookings ADD CONSTRAINT bookings_status_check 
  CHECK (status IN (
    'pending',
    'confirmed', 
    'reschedule_requested',
    'reschedule_approved',
    'reschedule_declined', 
    'completed',
    'cancelled',
    'no_show'
  ));
END $$;

-- =========================================================================
-- Phase 1: Reschedule Requests Table
-- =========================================================================

-- Create comprehensive reschedule_requests table
CREATE TABLE IF NOT EXISTS reschedule_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE CASCADE,
  customer_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  original_slot_id UUID NOT NULL REFERENCES available_slots(id),
  requested_slot_id UUID NOT NULL REFERENCES available_slots(id),
  original_date DATE NOT NULL,
  original_time TIME NOT NULL,
  requested_date DATE NOT NULL,
  requested_time TIME NOT NULL,
  reason TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'declined', 'expired')),
  admin_notes TEXT,
  temporary_reservation_id UUID,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  responded_at TIMESTAMPTZ,
  responded_by UUID REFERENCES auth.users(id),
  expires_at TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '72 hours'), -- Auto-expire after 72 hours
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add RLS policies for reschedule_requests
ALTER TABLE reschedule_requests ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view their own reschedule requests
CREATE POLICY "Users can view own reschedule requests" 
ON reschedule_requests FOR SELECT 
USING (customer_id = auth.uid());

-- Policy: Users can create reschedule requests for their bookings
CREATE POLICY "Users can create reschedule requests" 
ON reschedule_requests FOR INSERT 
WITH CHECK (customer_id = auth.uid());

-- Policy: Admins can view all reschedule requests
CREATE POLICY "Admins can view all reschedule requests" 
ON reschedule_requests FOR ALL 
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE users.id = auth.uid() 
    AND users.role IN ('admin', 'super_admin')
  )
);

-- =========================================================================
-- Phase 1: Indexes for Performance
-- =========================================================================

-- Create indexes for optimal query performance
CREATE INDEX IF NOT EXISTS idx_available_slots_status ON available_slots(slot_status);
CREATE INDEX IF NOT EXISTS idx_available_slots_booking ON available_slots(booking_id) WHERE booking_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_available_slots_reserved ON available_slots(reserved_for_user_id, reserved_until) WHERE reserved_for_user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_available_slots_date_time ON available_slots(slot_date, start_time);

CREATE INDEX IF NOT EXISTS idx_bookings_current_slot ON bookings(current_slot_id) WHERE current_slot_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_bookings_original_slot ON bookings(original_slot_id) WHERE original_slot_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_bookings_status_change ON bookings(last_status_change);
CREATE INDEX IF NOT EXISTS idx_bookings_user_status ON bookings(user_id, status);

CREATE INDEX IF NOT EXISTS idx_reschedule_requests_booking ON reschedule_requests(booking_id);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_customer ON reschedule_requests(customer_id);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_status ON reschedule_requests(status);
CREATE INDEX IF NOT EXISTS idx_reschedule_requests_expires ON reschedule_requests(expires_at) WHERE status = 'pending';

-- =========================================================================
-- Phase 1: Stored Procedures for Slot Management
-- =========================================================================

-- Function: Create temporary reservation during booking process
CREATE OR REPLACE FUNCTION create_temporary_reservation(
  p_slot_id UUID,
  p_user_id UUID,
  p_duration_minutes INTEGER DEFAULT 10
) RETURNS BOOLEAN AS $$
DECLARE
  reservation_expires TIMESTAMPTZ;
BEGIN
  reservation_expires := NOW() + (p_duration_minutes || ' minutes')::INTERVAL;
  
  -- Check if slot is available
  IF EXISTS (
    SELECT 1 FROM available_slots 
    WHERE id = p_slot_id 
    AND slot_status = 'available'
    AND (current_bookings < max_bookings OR max_bookings IS NULL)
  ) THEN
    -- Create temporary reservation
    UPDATE available_slots 
    SET 
      reserved_for_user_id = p_user_id,
      reserved_until = reservation_expires,
      slot_status = 'temporarily_reserved',
      last_modified = NOW(),
      modification_reason = 'Temporary reservation for booking process'
    WHERE id = p_slot_id;
    
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Confirm booking and link to slot permanently  
CREATE OR REPLACE FUNCTION confirm_booking_and_slot(
  p_booking_id UUID,
  p_slot_id UUID
) RETURNS BOOLEAN AS $$
DECLARE
  booking_user_id UUID;
BEGIN
  -- Get the user_id from the booking
  SELECT user_id INTO booking_user_id FROM bookings WHERE id = p_booking_id;
  
  -- Verify the slot is temporarily reserved for this user
  IF EXISTS (
    SELECT 1 FROM available_slots 
    WHERE id = p_slot_id 
    AND reserved_for_user_id = booking_user_id
    AND slot_status = 'temporarily_reserved'
  ) THEN
    -- Update slot to confirmed booking
    UPDATE available_slots 
    SET 
      booking_id = p_booking_id,
      current_bookings = COALESCE(current_bookings, 0) + 1,
      slot_status = 'booked',
      reserved_for_user_id = NULL,
      reserved_until = NULL,
      last_modified = NOW(),
      modification_reason = 'Booking confirmed'
    WHERE id = p_slot_id;
    
    -- Update booking with slot information
    UPDATE bookings 
    SET 
      slot_id = p_slot_id,
      current_slot_id = p_slot_id,
      original_slot_id = COALESCE(original_slot_id, p_slot_id),
      last_status_change = NOW(),
      status_change_reason = 'Booking confirmed with slot'
    WHERE id = p_booking_id;
    
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Process reschedule request with slot management
CREATE OR REPLACE FUNCTION process_reschedule_request(
  p_booking_id UUID,
  p_new_slot_id UUID,
  p_reason TEXT DEFAULT 'Customer request'
) RETURNS UUID AS $$
DECLARE
  booking_rec RECORD;
  request_id UUID;
BEGIN
  -- Get booking details
  SELECT * INTO booking_rec FROM bookings WHERE id = p_booking_id;
  
  -- Create reschedule request
  INSERT INTO reschedule_requests (
    booking_id,
    customer_id,
    original_slot_id,
    requested_slot_id,
    original_date,
    original_time,
    requested_date,
    requested_time,
    reason
  )
  SELECT 
    p_booking_id,
    booking_rec.user_id,
    booking_rec.current_slot_id,
    p_new_slot_id,
    orig_slot.slot_date,
    orig_slot.start_time,
    new_slot.slot_date,
    new_slot.start_time,
    p_reason
  FROM available_slots orig_slot, available_slots new_slot
  WHERE orig_slot.id = booking_rec.current_slot_id
  AND new_slot.id = p_new_slot_id
  RETURNING id INTO request_id;
  
  -- Temporarily reserve the new slot
  UPDATE available_slots 
  SET 
    reserved_for_user_id = booking_rec.user_id,
    reserved_until = NOW() + INTERVAL '72 hours',
    slot_status = 'reschedule_reserved',
    last_modified = NOW(),
    modification_reason = 'Reserved for reschedule request'
  WHERE id = p_new_slot_id;
  
  -- Update original slot status
  UPDATE available_slots 
  SET 
    slot_status = 'pending_reschedule',
    last_modified = NOW(),
    modification_reason = 'Booking has pending reschedule request'
  WHERE id = booking_rec.current_slot_id;
  
  -- Update booking status
  UPDATE bookings 
  SET 
    status = 'reschedule_requested',
    last_status_change = NOW(),
    status_change_reason = 'Reschedule request submitted',
    reschedule_count = COALESCE(reschedule_count, 0) + 1
  WHERE id = p_booking_id;
  
  RETURN request_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Cleanup expired temporary reservations
CREATE OR REPLACE FUNCTION cleanup_expired_reservations() RETURNS INTEGER AS $$
DECLARE
  cleaned_count INTEGER := 0;
BEGIN
  -- Release expired temporary reservations
  UPDATE available_slots 
  SET 
    reserved_for_user_id = NULL,
    reserved_until = NULL,
    slot_status = 'available',
    last_modified = NOW(),
    modification_reason = 'Expired temporary reservation cleaned up'
  WHERE reserved_until < NOW() 
  AND slot_status IN ('temporarily_reserved', 'reschedule_reserved');
  
  GET DIAGNOSTICS cleaned_count = ROW_COUNT;
  
  -- Expire old reschedule requests
  UPDATE reschedule_requests 
  SET 
    status = 'expired',
    responded_at = NOW()
  WHERE status = 'pending' 
  AND expires_at < NOW();
  
  RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =========================================================================
-- Phase 1: Update Triggers
-- =========================================================================

-- Trigger to update last_modified on available_slots changes
CREATE OR REPLACE FUNCTION update_available_slots_modified() RETURNS TRIGGER AS $$
BEGIN
  NEW.last_modified = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_available_slots_updated ON available_slots;
CREATE TRIGGER tr_available_slots_updated
  BEFORE UPDATE ON available_slots
  FOR EACH ROW
  EXECUTE FUNCTION update_available_slots_modified();

-- Trigger to update last_status_change on bookings status changes
CREATE OR REPLACE FUNCTION update_booking_status_change() RETURNS TRIGGER AS $$
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    NEW.last_status_change = NOW();
    NEW.booking_history = COALESCE(OLD.booking_history, '[]'::jsonb) || 
      jsonb_build_object(
        'timestamp', NOW(),
        'old_status', OLD.status,
        'new_status', NEW.status,
        'reason', NEW.status_change_reason
      );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_booking_status_updated ON bookings;
CREATE TRIGGER tr_booking_status_updated
  BEFORE UPDATE ON bookings
  FOR EACH ROW
  EXECUTE FUNCTION update_booking_status_change();

-- =========================================================================
-- Phase 1: Data Migration and Cleanup
-- =========================================================================

-- Migrate existing bookings to use new relationship structure
UPDATE bookings 
SET 
  current_slot_id = slot_id,
  original_slot_id = slot_id,
  last_status_change = COALESCE(updated_at, created_at),
  status_change_reason = 'Migrated from existing booking'
WHERE current_slot_id IS NULL AND slot_id IS NOT NULL;

-- Update available_slots to link existing bookings
UPDATE available_slots 
SET 
  booking_id = bookings.id,
  slot_status = CASE 
    WHEN bookings.status = 'confirmed' THEN 'booked'
    WHEN bookings.status = 'cancelled' THEN 'available'
    ELSE 'booked'
  END,
  current_bookings = 1,
  last_modified = NOW(),
  modification_reason = 'Migrated existing booking relationship'
FROM bookings 
WHERE available_slots.id = bookings.slot_id
AND available_slots.booking_id IS NULL;

-- Set available_slots without bookings to available status
UPDATE available_slots 
SET 
  slot_status = 'available',
  current_bookings = 0,
  last_modified = NOW(),
  modification_reason = 'Set as available - no linked booking'
WHERE booking_id IS NULL AND slot_status IS NULL;

-- =========================================================================
-- Phase 1: Grant Permissions
-- =========================================================================

-- Grant access to authenticated users for new functions
GRANT EXECUTE ON FUNCTION create_temporary_reservation TO authenticated;
GRANT EXECUTE ON FUNCTION confirm_booking_and_slot TO authenticated;
GRANT EXECUTE ON FUNCTION process_reschedule_request TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_expired_reservations TO service_role;

-- =========================================================================
-- Phase 1: Comments and Documentation
-- =========================================================================

COMMENT ON TABLE reschedule_requests IS 'Tracks all booking reschedule requests with complete slot management';
COMMENT ON COLUMN available_slots.slot_status IS 'Current status of the slot in the booking lifecycle';
COMMENT ON COLUMN available_slots.booking_id IS 'Direct link to the booking occupying this slot';
COMMENT ON COLUMN bookings.booking_history IS 'JSON array tracking all status changes and reasons';
COMMENT ON FUNCTION create_temporary_reservation IS 'Temporarily reserves a slot during the booking process';
COMMENT ON FUNCTION confirm_booking_and_slot IS 'Confirms booking and permanently links to slot';
COMMENT ON FUNCTION process_reschedule_request IS 'Creates reschedule request with proper slot management';

-- Migration completed successfully
SELECT 'Phase 1: Comprehensive Booking & Slot Relationship Management - Migration Completed' as migration_status;