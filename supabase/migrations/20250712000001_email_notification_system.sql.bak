-- Email Notification System for Love4Detailing
-- Comprehensive email tracking and user preferences

-- Email notifications tracking table
CREATE TABLE IF NOT EXISTS email_notifications (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    booking_id UUID REFERENCES bookings(id) ON DELETE SET NULL,
    email_type VARCHAR(50) NOT NULL CHECK (email_type IN (
        'booking_confirmation',
        'booking_reminder', 
        'booking_cancellation',
        'booking_rescheduling',
        'service_completion',
        'welcome_bonus',
        'points_earned',
        'tier_upgrade',
        'follow_up_reminder'
    )),
    email_address VARCHAR(255) NOT NULL,
    subject TEXT NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    delivery_status VARCHAR(20) DEFAULT 'pending' CHECK (delivery_status IN ('pending', 'delivered', 'failed', 'bounced')),
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    resend_message_id VARCHAR(255), -- Resend API message ID for tracking
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email preferences table for user customization
CREATE TABLE IF NOT EXISTS user_email_preferences (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    booking_confirmations BOOLEAN DEFAULT true,
    booking_reminders BOOLEAN DEFAULT true,
    booking_updates BOOLEAN DEFAULT true, -- cancellations, rescheduling
    service_notifications BOOLEAN DEFAULT true, -- completion, follow-ups
    loyalty_notifications BOOLEAN DEFAULT true, -- points, tier upgrades
    marketing_emails BOOLEAN DEFAULT true,
    weekly_digest BOOLEAN DEFAULT false,
    sms_notifications BOOLEAN DEFAULT false, -- for future SMS integration
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email templates table for dynamic content
CREATE TABLE IF NOT EXISTS email_templates (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    template_type VARCHAR(50) NOT NULL UNIQUE CHECK (template_type IN (
        'booking_confirmation_customer',
        'booking_confirmation_admin',
        'booking_reminder',
        'booking_cancellation',
        'booking_rescheduling',
        'service_completion',
        'welcome_bonus',
        'points_earned',
        'tier_upgrade',
        'follow_up_reminder'
    )),
    subject_template TEXT NOT NULL,
    html_template TEXT NOT NULL,
    text_template TEXT, -- Plain text fallback
    variables JSON, -- Template variable definitions
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_notifications_user_id ON email_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_email_notifications_booking_id ON email_notifications(booking_id);
CREATE INDEX IF NOT EXISTS idx_email_notifications_type ON email_notifications(email_type);
CREATE INDEX IF NOT EXISTS idx_email_notifications_sent_at ON email_notifications(sent_at);
CREATE INDEX IF NOT EXISTS idx_email_notifications_delivery_status ON email_notifications(delivery_status);

-- Enable RLS (Row Level Security)
ALTER TABLE email_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_email_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies for email_notifications
CREATE POLICY "Users can view their own email notifications"
    ON email_notifications FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all email notifications"
    ON email_notifications FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert email notifications"
    ON email_notifications FOR INSERT
    WITH CHECK (true); -- Allow system to insert notifications

CREATE POLICY "Admins can update email notifications"
    ON email_notifications FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- RLS Policies for user_email_preferences
CREATE POLICY "Users can manage their own email preferences"
    ON user_email_preferences FOR ALL
    USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all email preferences"
    ON user_email_preferences FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- RLS Policies for email_templates
CREATE POLICY "Everyone can view active email templates"
    ON email_templates FOR SELECT
    USING (is_active = true);

CREATE POLICY "Admins can manage email templates"
    ON email_templates FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Function to create default email preferences for new users
CREATE OR REPLACE FUNCTION create_default_email_preferences()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO user_email_preferences (user_id)
    VALUES (NEW.id)
    ON CONFLICT (user_id) DO NOTHING;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create default preferences when user signs up
CREATE TRIGGER on_auth_user_created_email_preferences
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION create_default_email_preferences();

-- Function to update email preferences updated_at timestamp
CREATE OR REPLACE FUNCTION update_email_preferences_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for email preferences updated_at
CREATE TRIGGER update_email_preferences_updated_at_trigger
    BEFORE UPDATE ON user_email_preferences
    FOR EACH ROW
    EXECUTE FUNCTION update_email_preferences_updated_at();

-- Function to get user email preferences with defaults
CREATE OR REPLACE FUNCTION get_user_email_preferences(user_uuid UUID)
RETURNS TABLE (
    booking_confirmations BOOLEAN,
    booking_reminders BOOLEAN,
    booking_updates BOOLEAN,
    service_notifications BOOLEAN,
    loyalty_notifications BOOLEAN,
    marketing_emails BOOLEAN,
    weekly_digest BOOLEAN,
    sms_notifications BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(uep.booking_confirmations, true),
        COALESCE(uep.booking_reminders, true),
        COALESCE(uep.booking_updates, true),
        COALESCE(uep.service_notifications, true),
        COALESCE(uep.loyalty_notifications, true),
        COALESCE(uep.marketing_emails, true),
        COALESCE(uep.weekly_digest, false),
        COALESCE(uep.sms_notifications, false)
    FROM user_email_preferences uep
    WHERE uep.user_id = user_uuid
    UNION ALL
    SELECT true, true, true, true, true, true, false, false
    WHERE NOT EXISTS (
        SELECT 1 FROM user_email_preferences WHERE user_id = user_uuid
    )
    LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to log email notification
CREATE OR REPLACE FUNCTION log_email_notification(
    p_user_id UUID,
    p_booking_id UUID,
    p_email_type VARCHAR,
    p_email_address VARCHAR,
    p_subject TEXT,
    p_resend_message_id VARCHAR DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    notification_id UUID;
BEGIN
    INSERT INTO email_notifications (
        user_id,
        booking_id,
        email_type,
        email_address,
        subject,
        resend_message_id,
        delivery_status
    ) VALUES (
        p_user_id,
        p_booking_id,
        p_email_type,
        p_email_address,
        p_subject,
        p_resend_message_id,
        'delivered'
    ) RETURNING id INTO notification_id;
    
    RETURN notification_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to update email delivery status
CREATE OR REPLACE FUNCTION update_email_delivery_status(
    p_message_id VARCHAR,
    p_status VARCHAR,
    p_error_message TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE email_notifications 
    SET 
        delivery_status = p_status,
        error_message = p_error_message,
        opened_at = CASE WHEN p_status = 'opened' THEN NOW() ELSE opened_at END
    WHERE resend_message_id = p_message_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Insert default email templates
INSERT INTO email_templates (template_type, subject_template, html_template, variables) VALUES 
(
    'booking_confirmation_customer',
    'Booking Confirmed - Your Love4Detailing Service',
    '<!-- Customer booking confirmation template -->',
    '{"customer_name": "string", "booking_reference": "string", "service_date": "string", "service_time": "string", "service_name": "string", "vehicle_make": "string", "vehicle_model": "string", "total_price": "number"}'
),
(
    'booking_confirmation_admin', 
    'New Booking Received - {{customer_name}}',
    '<!-- Admin booking notification template -->',
    '{"customer_name": "string", "booking_reference": "string", "service_date": "string", "service_time": "string", "customer_phone": "string", "customer_email": "string"}'
),
(
    'welcome_bonus',
    'Welcome to Love4Detailing! Your 50 Bonus Points Await',
    '<!-- Welcome bonus template -->',
    '{"customer_name": "string", "bonus_points": "number"}'
)
ON CONFLICT (template_type) DO NOTHING;

-- Email analytics view for reporting
CREATE OR REPLACE VIEW email_analytics AS
SELECT 
    email_type,
    DATE_TRUNC('day', sent_at) as date,
    COUNT(*) as total_sent,
    COUNT(CASE WHEN delivery_status = 'delivered' THEN 1 END) as delivered,
    COUNT(CASE WHEN delivery_status = 'failed' THEN 1 END) as failed,
    COUNT(CASE WHEN opened_at IS NOT NULL THEN 1 END) as opened,
    COUNT(CASE WHEN clicked_at IS NOT NULL THEN 1 END) as clicked,
    ROUND(
        COUNT(CASE WHEN delivery_status = 'delivered' THEN 1 END) * 100.0 / COUNT(*), 2
    ) as delivery_rate,
    ROUND(
        COUNT(CASE WHEN opened_at IS NOT NULL THEN 1 END) * 100.0 / 
        COUNT(CASE WHEN delivery_status = 'delivered' THEN 1 END), 2
    ) as open_rate,
    ROUND(
        COUNT(CASE WHEN clicked_at IS NOT NULL THEN 1 END) * 100.0 / 
        COUNT(CASE WHEN opened_at IS NOT NULL THEN 1 END), 2
    ) as click_rate
FROM email_notifications 
WHERE sent_at >= NOW() - INTERVAL '30 days'
GROUP BY email_type, DATE_TRUNC('day', sent_at)
ORDER BY date DESC, email_type;

-- Grant permissions for the service role to manage emails
GRANT ALL ON email_notifications TO service_role;
GRANT ALL ON user_email_preferences TO service_role;
GRANT ALL ON email_templates TO service_role;
GRANT ALL ON email_analytics TO service_role;

-- Comments for documentation
COMMENT ON TABLE email_notifications IS 'Tracks all email notifications sent to users with delivery status and engagement metrics';
COMMENT ON TABLE user_email_preferences IS 'User preferences for different types of email notifications';
COMMENT ON TABLE email_templates IS 'Configurable email templates with dynamic content variables';
COMMENT ON FUNCTION get_user_email_preferences(UUID) IS 'Returns user email preferences with fallback to defaults';
COMMENT ON FUNCTION log_email_notification(UUID, UUID, VARCHAR, VARCHAR, TEXT, VARCHAR) IS 'Logs email notification for tracking and analytics';
COMMENT ON VIEW email_analytics IS 'Email performance analytics including delivery, open, and click rates';