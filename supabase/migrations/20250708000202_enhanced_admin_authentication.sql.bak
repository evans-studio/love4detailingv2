-- Enhanced Admin Authentication System
-- Addresses Issue #012: Strengthen authentication process for admin access

-- Create admin invitations table for controlled admin access
CREATE TABLE IF NOT EXISTS admin_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL UNIQUE,
    invitation_token TEXT NOT NULL UNIQUE,
    invited_by UUID REFERENCES users(id) ON DELETE SET NULL,
    role admin_role NOT NULL DEFAULT 'admin',
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (NOW() + INTERVAL '7 days'),
    accepted_at TIMESTAMP WITH TIME ZONE,
    accepted_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create admin role enum if it doesn't exist
DO $$ BEGIN
    CREATE TYPE admin_role AS ENUM ('admin', 'super_admin', 'staff');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Update users table to use the admin_role enum for role field
DO $$ 
BEGIN
    -- First check if we need to update the column type
    IF EXISTS (SELECT 1 FROM information_schema.columns 
               WHERE table_name = 'users' AND column_name = 'role' AND data_type = 'text') THEN
        -- Update existing text roles to match enum values
        UPDATE users SET role = 'super_admin' WHERE role = 'admin';
        UPDATE users SET role = 'admin' WHERE role NOT IN ('super_admin', 'admin', 'staff', 'customer');
        
        -- Change column type
        ALTER TABLE users ALTER COLUMN role TYPE admin_role USING role::admin_role;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- If there's an error, the column might already be the right type
        NULL;
END $$;

-- Enable RLS on admin_invitations
ALTER TABLE admin_invitations ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for admin_invitations
CREATE POLICY "admin_invitations_super_admin_access" ON admin_invitations FOR ALL TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM users 
        WHERE users.id = auth.uid() 
        AND users.role = 'super_admin'
    )
);

-- Policy for accepting invitations (any authenticated user can accept their own invitation)
CREATE POLICY "admin_invitations_accept_own" ON admin_invitations FOR SELECT TO authenticated
USING (
    email = (SELECT email FROM auth.users WHERE id = auth.uid())
    AND expires_at > NOW()
    AND accepted_at IS NULL
);

-- Grant permissions
GRANT ALL ON admin_invitations TO authenticated;
GRANT ALL ON admin_invitations TO service_role;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_admin_invitations_email ON admin_invitations(email);
CREATE INDEX IF NOT EXISTS idx_admin_invitations_token ON admin_invitations(invitation_token);
CREATE INDEX IF NOT EXISTS idx_admin_invitations_expires ON admin_invitations(expires_at);

-- Function to create admin invitation
CREATE OR REPLACE FUNCTION create_admin_invitation(
    p_email TEXT,
    p_role admin_role DEFAULT 'admin',
    p_invited_by UUID DEFAULT NULL
) RETURNS TABLE (
    invitation_id UUID,
    email TEXT,
    invitation_token TEXT,
    role admin_role,
    expires_at TIMESTAMP WITH TIME ZONE,
    success BOOLEAN,
    message TEXT
) AS $$
DECLARE
    v_invitation_id UUID;
    v_token TEXT;
    v_expires_at TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Validate that inviter is super_admin
    IF p_invited_by IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM users WHERE id = p_invited_by AND role = 'super_admin') THEN
            RETURN QUERY SELECT 
                NULL::UUID, p_email, NULL::TEXT, p_role, NULL::TIMESTAMP WITH TIME ZONE,
                FALSE, 'Only super admins can create admin invitations'::TEXT;
            RETURN;
        END IF;
    END IF;
    
    -- Check if user already exists
    IF EXISTS (SELECT 1 FROM users WHERE email = p_email) THEN
        RETURN QUERY SELECT 
            NULL::UUID, p_email, NULL::TEXT, p_role, NULL::TIMESTAMP WITH TIME ZONE,
            FALSE, 'User with this email already exists'::TEXT;
        RETURN;
    END IF;
    
    -- Check if invitation already exists and is not expired
    IF EXISTS (SELECT 1 FROM admin_invitations 
               WHERE email = p_email AND expires_at > NOW() AND accepted_at IS NULL) THEN
        RETURN QUERY SELECT 
            NULL::UUID, p_email, NULL::TEXT, p_role, NULL::TIMESTAMP WITH TIME ZONE,
            FALSE, 'Active invitation already exists for this email'::TEXT;
        RETURN;
    END IF;
    
    -- Generate secure token
    v_token := encode(gen_random_bytes(32), 'hex');
    v_expires_at := NOW() + INTERVAL '7 days';
    
    -- Create invitation
    INSERT INTO admin_invitations (email, invitation_token, invited_by, role, expires_at)
    VALUES (p_email, v_token, p_invited_by, p_role, v_expires_at)
    RETURNING id INTO v_invitation_id;
    
    RETURN QUERY SELECT 
        v_invitation_id, p_email, v_token, p_role, v_expires_at,
        TRUE, 'Admin invitation created successfully'::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT 
            NULL::UUID, p_email, NULL::TEXT, p_role, NULL::TIMESTAMP WITH TIME ZONE,
            FALSE, SQLERRM::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to accept admin invitation
CREATE OR REPLACE FUNCTION accept_admin_invitation(
    p_invitation_token TEXT,
    p_user_id UUID
) RETURNS TABLE (
    success BOOLEAN,
    role admin_role,
    message TEXT
) AS $$
DECLARE
    v_invitation RECORD;
    v_user_email TEXT;
BEGIN
    -- Get user email
    SELECT email INTO v_user_email
    FROM auth.users
    WHERE id = p_user_id;
    
    IF v_user_email IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::admin_role, 'User not found'::TEXT;
        RETURN;
    END IF;
    
    -- Get invitation
    SELECT * INTO v_invitation
    FROM admin_invitations
    WHERE invitation_token = p_invitation_token
    AND email = v_user_email
    AND expires_at > NOW()
    AND accepted_at IS NULL;
    
    IF v_invitation.id IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::admin_role, 'Invalid or expired invitation'::TEXT;
        RETURN;
    END IF;
    
    -- Update user role
    UPDATE users
    SET 
        role = v_invitation.role,
        updated_at = NOW()
    WHERE id = p_user_id;
    
    -- Mark invitation as accepted
    UPDATE admin_invitations
    SET 
        accepted_at = NOW(),
        accepted_by = p_user_id,
        updated_at = NOW()
    WHERE id = v_invitation.id;
    
    RETURN QUERY SELECT TRUE, v_invitation.role, 'Admin invitation accepted successfully'::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT FALSE, NULL::admin_role, SQLERRM::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to validate admin session
CREATE OR REPLACE FUNCTION validate_admin_session(
    p_user_id UUID
) RETURNS TABLE (
    is_admin BOOLEAN,
    role admin_role,
    permissions JSONB,
    session_valid BOOLEAN
) AS $$
DECLARE
    v_user RECORD;
    v_permissions JSONB;
BEGIN
    -- Get user details
    SELECT * INTO v_user
    FROM users
    WHERE id = p_user_id
    AND role IN ('admin', 'super_admin', 'staff');
    
    IF v_user.id IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::admin_role, '{}'::JSONB, FALSE;
        RETURN;
    END IF;
    
    -- Build permissions object based on role
    CASE v_user.role
        WHEN 'super_admin' THEN
            v_permissions := jsonb_build_object(
                'can_manage_users', true,
                'can_manage_schedule', true,
                'can_manage_bookings', true,
                'can_view_analytics', true,
                'can_manage_settings', true,
                'can_invite_admins', true,
                'can_delete_data', true
            );
        WHEN 'admin' THEN
            v_permissions := jsonb_build_object(
                'can_manage_users', false,
                'can_manage_schedule', true,
                'can_manage_bookings', true,
                'can_view_analytics', true,
                'can_manage_settings', false,
                'can_invite_admins', false,
                'can_delete_data', false
            );
        WHEN 'staff' THEN
            v_permissions := jsonb_build_object(
                'can_manage_users', false,
                'can_manage_schedule', false,
                'can_manage_bookings', true,
                'can_view_analytics', false,
                'can_manage_settings', false,
                'can_invite_admins', false,
                'can_delete_data', false
            );
        ELSE
            v_permissions := '{}'::JSONB;
    END CASE;
    
    RETURN QUERY SELECT TRUE, v_user.role, v_permissions, TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to list admin invitations (super admin only)
CREATE OR REPLACE FUNCTION get_admin_invitations(
    p_admin_user_id UUID
) RETURNS TABLE (
    invitation_id UUID,
    email TEXT,
    role admin_role,
    invited_by_email TEXT,
    expires_at TIMESTAMP WITH TIME ZONE,
    accepted_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    -- Validate that requester is super_admin
    IF NOT EXISTS (SELECT 1 FROM users WHERE id = p_admin_user_id AND role = 'super_admin') THEN
        RAISE EXCEPTION 'Only super admins can view admin invitations';
    END IF;
    
    RETURN QUERY
    SELECT 
        ai.id,
        ai.email,
        ai.role,
        u.email as invited_by_email,
        ai.expires_at,
        ai.accepted_at,
        ai.created_at
    FROM admin_invitations ai
    LEFT JOIN users u ON u.id = ai.invited_by
    ORDER BY ai.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions for new functions
GRANT EXECUTE ON FUNCTION create_admin_invitation(TEXT, admin_role, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION create_admin_invitation(TEXT, admin_role, UUID) TO service_role;
GRANT EXECUTE ON FUNCTION accept_admin_invitation(TEXT, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION accept_admin_invitation(TEXT, UUID) TO service_role;
GRANT EXECUTE ON FUNCTION validate_admin_session(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION validate_admin_session(UUID) TO service_role;
GRANT EXECUTE ON FUNCTION get_admin_invitations(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_admin_invitations(UUID) TO service_role;