-- Simplified Slots System Migration
-- Based on schedule.md requirements for Love4Detailing
-- Eliminates overcomplicated capacity management and template system

-- Drop existing complex slot-related tables and functions
DROP TABLE IF EXISTS slot_bookings CASCADE;
DROP TABLE IF EXISTS booking_locks CASCADE;
DROP TABLE IF EXISTS schedule_slots CASCADE;
DROP TABLE IF EXISTS schedule_templates CASCADE;

-- Drop complex stored procedures
DROP FUNCTION IF EXISTS get_enhanced_available_slots() CASCADE;
DROP FUNCTION IF EXISTS manage_time_slot() CASCADE;
DROP FUNCTION IF EXISTS book_time_slot() CASCADE;
DROP FUNCTION IF EXISTS generate_available_slots_from_template() CASCADE;
DROP FUNCTION IF EXISTS add_booking_slot() CASCADE;
DROP FUNCTION IF EXISTS edit_booking_slot() CASCADE;
DROP FUNCTION IF EXISTS delete_booking_slot() CASCADE;
DROP FUNCTION IF EXISTS get_day_slots() CASCADE;
DROP FUNCTION IF EXISTS get_week_overview() CASCADE;
DROP FUNCTION IF EXISTS copy_slots_to_days() CASCADE;
DROP FUNCTION IF EXISTS toggle_working_day() CASCADE;

-- Create simplified available_slots table
-- This replaces the complex multi-table structure with a single source of truth
-- Fixed duration services (45min-1hr) mean we only need start_time, not end_time
CREATE TABLE IF NOT EXISTS available_slots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slot_date DATE NOT NULL,
    start_time TIME NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT TRUE,
    booking_id UUID REFERENCES bookings(id) ON DELETE SET NULL,
    
    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Ensure unique slots per date/time combination
    UNIQUE(slot_date, start_time)
);

-- Create indexes for performance
CREATE INDEX idx_available_slots_date ON available_slots(slot_date);
CREATE INDEX idx_available_slots_available ON available_slots(is_available);
CREATE INDEX idx_available_slots_booking ON available_slots(booking_id);
CREATE INDEX idx_available_slots_datetime ON available_slots(slot_date, start_time);

-- Update trigger for updated_at
CREATE OR REPLACE FUNCTION update_available_slots_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_available_slots_updated_at
    BEFORE UPDATE ON available_slots
    FOR EACH ROW
    EXECUTE FUNCTION update_available_slots_updated_at();

-- RLS Policies for available_slots
ALTER TABLE available_slots ENABLE ROW LEVEL SECURITY;

-- Admin can do everything
CREATE POLICY available_slots_admin_all ON available_slots
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_profiles.user_id = auth.uid() 
            AND user_profiles.role = 'admin'
        )
    );

-- Authenticated users can view available slots
CREATE POLICY available_slots_user_select ON available_slots
    FOR SELECT USING (auth.role() = 'authenticated');

-- Anonymous users can view available slots
CREATE POLICY available_slots_anon_select ON available_slots
    FOR SELECT USING (auth.role() = 'anon');

-- Simplified stored procedures for slot management

-- Get available slots for a specific date
CREATE OR REPLACE FUNCTION get_available_slots_for_date(target_date DATE)
RETURNS TABLE (
    slot_id UUID,
    slot_date DATE,
    start_time TIME,
    is_available BOOLEAN,
    booking_reference TEXT
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id,
        s.slot_date,
        s.start_time,
        s.is_available,
        b.booking_reference
    FROM available_slots s
    LEFT JOIN bookings b ON s.booking_id = b.id
    WHERE s.slot_date = target_date
    ORDER BY s.start_time;
END;
$$;

-- Get available slots for date range (for admin overview)
CREATE OR REPLACE FUNCTION get_slots_for_date_range(start_date DATE, end_date DATE)
RETURNS TABLE (
    slot_id UUID,
    slot_date DATE,
    start_time TIME,
    is_available BOOLEAN,
    booking_id UUID,
    booking_reference TEXT,
    customer_name TEXT
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id,
        s.slot_date,
        s.start_time,
        s.is_available,
        s.booking_id,
        b.booking_reference,
        COALESCE(p.full_name, b.guest_customer_name) as customer_name
    FROM available_slots s
    LEFT JOIN bookings b ON s.booking_id = b.id
    LEFT JOIN user_profiles p ON b.user_id = p.user_id
    WHERE s.slot_date BETWEEN start_date AND end_date
    ORDER BY s.slot_date, s.start_time;
END;
$$;

-- Create a new available slot
CREATE OR REPLACE FUNCTION create_available_slot(
    slot_date DATE,
    start_time TIME
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    new_slot_id UUID;
BEGIN
    -- Check if slot already exists
    IF EXISTS (
        SELECT 1 FROM available_slots 
        WHERE available_slots.slot_date = create_available_slot.slot_date 
        AND available_slots.start_time = create_available_slot.start_time
    ) THEN
        RAISE EXCEPTION 'Slot already exists for this date and time';
    END IF;
    
    -- Create the slot
    INSERT INTO available_slots (slot_date, start_time, is_available)
    VALUES (slot_date, start_time, TRUE)
    RETURNING id INTO new_slot_id;
    
    RETURN new_slot_id;
END;
$$;

-- Book a slot (link to booking)
CREATE OR REPLACE FUNCTION book_available_slot(
    slot_id UUID,
    booking_id UUID
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if slot is available
    IF NOT EXISTS (
        SELECT 1 FROM available_slots 
        WHERE id = slot_id AND is_available = TRUE
    ) THEN
        RAISE EXCEPTION 'Slot is not available for booking';
    END IF;
    
    -- Book the slot
    UPDATE available_slots 
    SET 
        is_available = FALSE,
        booking_id = book_available_slot.booking_id,
        updated_at = NOW()
    WHERE id = slot_id;
    
    RETURN TRUE;
END;
$$;

-- Release a slot (unlink from booking)
CREATE OR REPLACE FUNCTION release_available_slot(slot_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE available_slots 
    SET 
        is_available = TRUE,
        booking_id = NULL,
        updated_at = NOW()
    WHERE id = slot_id;
    
    RETURN TRUE;
END;
$$;

-- Delete an available slot (only if not booked)
CREATE OR REPLACE FUNCTION delete_available_slot(slot_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if slot is booked
    IF EXISTS (
        SELECT 1 FROM available_slots 
        WHERE id = slot_id AND booking_id IS NOT NULL
    ) THEN
        RAISE EXCEPTION 'Cannot delete booked slot';
    END IF;
    
    DELETE FROM available_slots WHERE id = slot_id;
    
    RETURN TRUE;
END;
$$;

-- Bulk create slots for a week (admin convenience function)
CREATE OR REPLACE FUNCTION create_weekly_slots(
    week_start_date DATE,
    time_slots TIME[]
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_date DATE;
    time_slot TIME;
    slots_created INTEGER := 0;
    end_time TIME;
BEGIN
    -- Loop through weekdays (Monday to Friday)
    FOR i IN 0..4 LOOP
        current_date := week_start_date + i;
        
        -- Loop through time slots
        FOREACH time_slot IN ARRAY time_slots
        LOOP
            -- Create slot if it doesn't exist
            IF NOT EXISTS (
                SELECT 1 FROM available_slots 
                WHERE slot_date = current_date AND start_time = time_slot
            ) THEN
                INSERT INTO available_slots (slot_date, start_time, is_available)
                VALUES (current_date, time_slot, TRUE);
                slots_created := slots_created + 1;
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN slots_created;
END;
$$;

-- Seed some initial slots for testing (conservative approach as per schedule.md)
-- Week 1: Limited availability - 4 slots total across weekdays
DO $$
DECLARE
    next_monday DATE;
BEGIN
    -- Find next Monday
    next_monday := CURRENT_DATE + (7 - EXTRACT(dow FROM CURRENT_DATE) + 1) % 7;
    
    -- Create limited slots as per schedule.md requirements
    -- Monday: 10:00
    INSERT INTO available_slots (slot_date, start_time, is_available)
    VALUES (next_monday, '10:00'::TIME, TRUE)
    ON CONFLICT (slot_date, start_time) DO NOTHING;
    
    -- Tuesday: 14:00  
    INSERT INTO available_slots (slot_date, start_time, is_available)
    VALUES (next_monday + 1, '14:00'::TIME, TRUE)
    ON CONFLICT (slot_date, start_time) DO NOTHING;
    
    -- Wednesday: OFF (no slots)
    
    -- Thursday: 16:00
    INSERT INTO available_slots (slot_date, start_time, is_available)
    VALUES (next_monday + 3, '16:00'::TIME, TRUE)
    ON CONFLICT (slot_date, start_time) DO NOTHING;
    
    -- Friday: 12:00
    INSERT INTO available_slots (slot_date, start_time, is_available)
    VALUES (next_monday + 4, '12:00'::TIME, TRUE)
    ON CONFLICT (slot_date, start_time) DO NOTHING;
    
END $$;

-- Grant permissions
GRANT SELECT ON available_slots TO authenticated, anon;
GRANT ALL ON available_slots TO service_role;

-- Grant execute permissions on functions
GRANT EXECUTE ON FUNCTION get_available_slots_for_date(DATE) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION get_slots_for_date_range(DATE, DATE) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION create_available_slot(DATE, TIME) TO service_role;
GRANT EXECUTE ON FUNCTION book_available_slot(UUID, UUID) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION release_available_slot(UUID) TO service_role;
GRANT EXECUTE ON FUNCTION delete_available_slot(UUID) TO service_role;
GRANT EXECUTE ON FUNCTION create_weekly_slots(DATE, TIME[]) TO service_role;

-- Add comment explaining the simplified approach
COMMENT ON TABLE available_slots IS 'Simplified slot system: Each slot is either available (TRUE) or booked (FALSE). Fixed duration services (45min-1hr) with one-customer-per-slot business model.';